#' Estimation Parameters Using SPARSim
#'
#' @param SCST_Object A SCST object generated by [SCST::Create_SCST_Object()]
#' @param verbose Whether to return messages or not
#' @param ... Other parameters represented in SRTsim, see [SPARSim::SPARSim_estimate_parameter_from_data()]
#'
#' @export
#'
#' @references Baruzzo G, Patuzzi I, Di Camillo B. SPARSim single cell: a count data simulator for scRNA-seq data[J]. Bioinformatics, 2020, 36(5): 1468-1475.
#'
SPARSim_estimation <- function(SCST_Object,
                               verbose = FALSE,
                               ...
){
  ##############################################################################
  ####                            Environment                                ###
  ##############################################################################
  if(!requireNamespace("SPARSim", quietly = TRUE)){
    message("SPARSim is not installed on your device...")
    message("Installing SPARSim...")
    devtools::install_gitlab("sysbiobig/sparsim")
  }
  if(!requireNamespace("scater", quietly = TRUE)){
    message("scater is not installed on your device...")
    message("Installing scater...")
    BiocManager::install("scater")
  }
  ref_data <- as.matrix(methods::slot(SCST_Object, "reference"))
  condition_label <- methods::slot(SCST_Object, "group_label")
  # if(S4Vectors::isEmpty(condition_label)){
  #   condition_label <- methods::slot(SCST_Object, "batch_label")
  # }
  dilution_factor <- methods::slot(SCST_Object, "dilution_factor")
  volume <- methods::slot(SCST_Object, "volume")
  seed <- methods::slot(SCST_Object, "seed")
  ##############################################################################
  ####                               Check                                   ###
  ##############################################################################
  colnames(ref_data) <- gsub(pattern = "_", replacement = ".", colnames(ref_data))
  if(S4Vectors::isEmpty(condition_label)){
    count_matrix_conditions <- list(conditionA = 1:ncol(ref_data))
  }else{
    count_matrix_conditions <- list()
    condition <- unique(condition_label)
    for(i in 1:length(condition)){
      index <- which(condition_label == condition[i])
      count_matrix_conditions[[paste0("cond_", as.character(condition[i]))]] <- index
    }
  }
  # External parameters
  ext_argument <- list(...)
  argument <- formals(SPARSim::SPARSim_estimate_parameter_from_data)
  used_argument <- change_parameters(ext_argument, argument)
  used_argument[["raw_data"]] <- ref_data
  used_argument[["norm_data"]] <- scater::normalizeCounts(ref_data)
  used_argument[["conditions"]] <- count_matrix_conditions

  if(!S4Vectors::isEmpty(dilution_factor) & !!S4Vectors::isEmpty(volume)){
    if(S4Vectors::isEmpty(grep(rownames(ref_data), pattern = "^ERCC"))){
      stop("Make sure the gene names of ERCC spike-in RNA must have the prefix of 'ERCC-'")
    }
    ERCC_index <- grep(rownames(ref_data), pattern = "^ERCC")
    ERCC_counts <- ref_data[ERCC_index, ]
    ref_data <- ref_data[-ERCC_index, ]
    ref_data <- rbind(ref_data, ERCC_counts)
    ERCC_info <- SCST::ERCC_info
    ERCC_info <- ERCC_info[which(rownames(ERCC_counts) %in% ERCC_info$ERCC_id), ]
    concentration <- ERCC_info$con_Mix1_attomoles_ul
    spikein_abund <- concentration*10^-18*6.022*10^23*volume/dilution_factor
    spikein <- SPARSim::SPARSim_create_spikein_mix(mix_name= "spikein",
                                                   abundance = spikein_abund)
    spikein_set <- SPARSim::SPARSim_create_spikein_set(spikein_mixes = list(spikein = spikein))
    spikein_sample_association <- c(rep("spikein", ncol(ref_data)))
    spikein_abundance <- 0.05
    SPARSim_spikein_parameter <- SPARSim::SPARSim_create_spikein_parameter(
      spikein_set = spikein_set,
      spikein_sample = spikein_sample_association,
      spikein_proportion = spikein_abundance)
  }else{
    SPARSim_spikein_parameter <- NULL
  }
  ##############################################################################
  ####                            Estimation                                 ###
  ##############################################################################
  # Seed
  set.seed(seed)
  # Estimation
  estimate_detection <- peakRAM::peakRAM(
    estimate_result <- do.call(SPARSim::SPARSim_estimate_parameter_from_data, used_argument)
  )
  estimate_result <- list(estimate_result = estimate_result,
                          SPARSim_spikein_parameter = SPARSim_spikein_parameter)
  ##############################################################################
  ####                           Ouput                                       ###
  ##############################################################################
  slot(SCST_Object, "estimation_time_memory") <- list("SPARSim" = list("estimation_time" = estimate_detection$Elapsed_Time_sec,
                                                                       "estimation_memory" = estimate_detection$Peak_RAM_Used_MiB))
  slot(SCST_Object, "estimation_result") <- list("SPARSim" = estimate_result)
  slot(SCST_Object, "estimation_parameters") <- list("SPARSim" = used_argument[-c(1:2)])
  return(SCST_Object)
}



#' Simulate ST Data Using SPARSim
#'
#' @param estimated_result The SCST object after estimating parameters using [SPARSim::SPARSim_estimate_parameter_from_data()]
#' @param de_prop The proportion of DEGs over all genes between different simulated cell groups. SPARSim can only simulated cell groups if users provide group labels of reference cells to estimate parameters. Otherwise, the cell groups can not be simulated in this step and `de_prop` parameter is useless. Default is 0.2.
#' @param fc_group The fold change of the generated DEGs. This parameter works when the reference cell groups are provided in the estimation step. Default is 2.
#' @param nBatches The number of cell batches to be simulated. Default is 1.
#' @param prop_batch The proportion of cells in each batch. Default is 1.
#' @param verbose Whether to return messages or not
#' @param seed Random seed
#' @param return_format The format of returned simulation data. Choices: list, SingleCellExperiment and Seurat.
#' @param ... Other parameters represented in SPARSim, see [SPARSim::srtsim_count()]
#'
#' @importFrom BiocGenerics append get
#' @importFrom dplyr %>%
#' @importFrom stringr str_split
#'
#' @export
#' @references Baruzzo G, Patuzzi I, Di Camillo B. SPARSim single cell: a count data simulator for scRNA-seq data. Bioinformatics, 2020, 36(5): 1468-1475. <https://doi.org/10.1093/bioinformatics/btz752>
#'
SPARSim_simulation <- function(estimated_result,
                               de_prop = 0.2,
                               fc_group = 2,
                               nBatches = 1,
                               prop_batch = 1,
                               verbose = FALSE,
                               seed,
                               return_format,
                               ...
){
  ##############################################################################
  ####                               Check                                   ###
  ##############################################################################
  if(!requireNamespace("SPARSim", quietly = TRUE)){
    message("SPARSim is not installed on your device...")
    message("Installing SPARSim...")
    devtools::install_gitlab("sysbiobig/sparsim")
  }
  if(methods::is(estimated_result, "SCST")){
    input <- estimated_result@estimation_result$SPARSim
  }else{
    stop("Please input the estimated result which is a SCST object")
  }
  nCells <- estimated_result@customed_setting$cell_num
  # External parameters
  ext_argument <- list(...)
  argument <- formals(SPARSim::SPARSim_simulation)
  used_argument <- change_parameters(ext_argument, argument)
  used_argument[["dataset_parameter"]] <- input[["estimate_result"]]
  used_argument[["spikein_parameter"]] <- input[["SPARSim_spikein_parameter"]]
  parameters <- input[["estimate_result"]]
  ##############################################################################
  ####                               Check                                   ###
  ##############################################################################
  ## Batch
  if(nBatches > 1){
    used_argument[["output_batch_matrix"]] <- TRUE
    if(is.null(ext_argument[["distribution"]])){
      ext_argument[["distribution"]] <- "normal"
    }
    if(nBatches != length(ext_argument[["distribution"]])){
      ext_argument[["distribution"]] <- rep(ext_argument[["distribution"]][1], nBatches)
    }
    assertthat::assert_that(nBatches == length(ext_argument[["distribution"]]),
                            msg = "The number of cell batches must equal to the vector of distributions")
    ## Default param A
    if(is.null(ext_argument[["param_A"]])){
      for(w in 1:length(ext_argument[["distribution"]])){
        dis <- ext_argument[["distribution"]][w]
        if(dis == "normal"){
          ext_argument[["param_A"]] <- BiocGenerics::append(ext_argument[["param_A"]], w-1)
        }
        if(dis == "gamma"){
          ext_argument[["param_A"]] <- BiocGenerics::append(ext_argument[["param_A"]], w)
        }
      }
    }
    ## Default param B
    if(is.null(ext_argument[["param_B"]])){
      for(w in 1:length(ext_argument[["distribution"]])){
        dis <- ext_argument[["distribution"]][w]
        if(dis == "normal"){
          ext_argument[["param_B"]] <- BiocGenerics::append(ext_argument[["param_B"]], w)
        }
        if(dis == "gamma"){
          ext_argument[["param_B"]] <- BiocGenerics::append(ext_argument[["param_B"]], w)
        }
      }
    }
    ## Check param length
    assertthat::assert_that(length(ext_argument[["param_A"]]) == length(ext_argument[["distribution"]]),
                            msg = "The length of param_A must equal to the vector of distributions \n")
    assertthat::assert_that(length(ext_argument[["param_B"]]) == length(ext_argument[["distribution"]]),
                            msg = "The length of param_B must equal to the vector of distributions \n")
    batch_set_tmp <- lapply(X = seq_len(length(ext_argument[["distribution"]])),
                            FUN = function(id){
                              SPARSim::SPARSim_create_batch(name = paste0("Batch", id),
                                                            distribution = ext_argument[["distribution"]][id],
                                                            param_A = ext_argument[["param_A"]][id],
                                                            param_B = ext_argument[["param_B"]][id])
                            }) %>% stats::setNames(paste0("Batch_", seq_len(length(ext_argument[["distribution"]]))))
    batch_set <- SPARSim::SPARSim_create_batch_set(batch_list = batch_set_tmp)
    if(S4Vectors::isEmpty(estimated_result@batch_label)){
      batch.condition <- SCST::proportionate(number = nCells,
                                             result_sum_strict = nCells,
                                             prop = prop_batch,
                                             prop_sum_strict = 1)
      batch.condition <- rep(seq_len(length(batch.condition)), batch.condition)
    }else{
      batch.condition <- as.numeric(as.factor(estimated_result@batch_label))
    }
    batch_sample_association <- paste0("Batch", batch.condition)
    SPARSim_batch_parameter <-SPARSim::SPARSim_create_batch_parameter(batch_set = batch_set,
                                                                      batch_sample = batch_sample_association)
    used_argument[["batch_parameter"]] <- SPARSim_batch_parameter
  }
  ## DEGs
  if(length(parameters) > 1 & nBatches == 1){
    ## gene number
    n_genes <- length(parameters[[1]][['intensity']])
    DE_gene_number <- round(n_genes * de_prop)
    DE_group <- SCST::proportionate(number = DE_gene_number,
                                    result_sum_strict = DE_gene_number,
                                    prop = rep(1/(length(parameters)-1), (length(parameters)-1)),
                                    prop_sum_strict = 1,
                                    digits = 0)
    cond_A_param <- parameters[[1]]
    SPARSim_param_with_DE <- list(cond_A = cond_A_param)
    for(group in seq_len(length(parameters)-1)){
      set.seed(seed)
      DE_multiplier <- c(stats::runif(n = ceiling(DE_group[group]/2),
                                      min = 1/fc_group * group,
                                      max = 1/fc_group * group),
                         stats::runif(n = floor(DE_group[group]/2),
                                      min = fc_group * group,
                                      max = fc_group * group))
      if(group >= 2){
        pre_DE <- sum(DE_group[1:(group-1)])
        if(group < 3){
          fold_change_multiplier_record <- fold_change_multiplier
        }
        fold_change_multiplier_record[(pre_DE+1):(pre_DE+length(DE_multiplier))] <- DE_multiplier
        fold_change_multiplier <- c(rep(1, pre_DE),
                                    DE_multiplier,
                                    rep(1, n_genes-pre_DE-length(DE_multiplier)))
      }else{
        not_DE_multiplier <- rep(1, n_genes-DE_group[group])
        fold_change_multiplier <- c(DE_multiplier, not_DE_multiplier)
        fold_change_multiplier_record <- NULL
      }
      cond_name <- paste0("cond_", LETTERS[group+1], "_param")
      assign(cond_name, parameters[[group+1]])

      assign(cond_name, SPARSim::SPARSim_create_DE_genes_parameter(
        sim_param = cond_A_param,
        fc_multiplier = fold_change_multiplier,
        N_cells = length(BiocGenerics::get(cond_name)[["lib_size"]]),
        lib_size_DE = BiocGenerics::get(cond_name)[["lib_size"]],
        condition_name = paste0("cond_", LETTERS[group+1]))
      )
      SPARSim_param_with_DE[[paste0("cond_", LETTERS[group+1])]] <- BiocGenerics::get(cond_name)
    }
    used_argument[["dataset_parameter"]] <- SPARSim_param_with_DE
  }
  ##############################################################################
  ####                            Simulation                                 ###
  ##############################################################################
  if(verbose){
    message("Simulating datasets using SPARSim")
  }
  # Seed
  set.seed(seed)
  # Estimation
  simulate_detection <- peakRAM::peakRAM(
    simulate_result <- do.call(SPARSim::SPARSim_simulation, used_argument)
  )
  used_argument[["seed"]] <- seed
  ##############################################################################
  ####                        Format Conversion                              ###
  ##############################################################################
  ## counts
  counts <- methods::as(simulate_result[["count_matrix"]], "dgCMatrix")
  if(!is.null(input[["spikein_parameter"]])){
    spikein_index <- BiocGenerics::grep(rownames(counts), pattern = "^spikein")
    filter_index <- (nrow(counts)-2*length(spikein_index)+1):(nrow(counts)-length(spikein_index))
    counts <- counts[-filter_index, ]
  }

  if(length(parameters) != 1 & nBatches == 1){
    group_name_tmp <- stringr::str_split(colnames(counts),
                                         pattern = "_",
                                         simplify = TRUE)[, 2]
    group_name <- unique(group_name_tmp)
    group <- rep("Group1", ncol(counts))
    for(i in 1:length(group_name)){
      index <- which(group_name[i] == group_name_tmp)
      group[index] <- rep(paste0("Group", i), length(index))
    }
  }else{
    group <- rep("Group1", ncol(counts))
  }
  rownames(counts) <- paste0("Gene", 1:nrow(counts))
  ## col_data
  if(!is.null(used_argument[["batch_parameter"]])){
    batch <- paste0("Batch", batch.condition)
    col_data <- data.frame("cell_name" = colnames(counts),
                           "group" = group,
                           "batch" = batch,
                           row.names = colnames(counts))
  }else{
    col_data <- data.frame("cell_name" = colnames(counts),
                           "group" = group,
                           row.names = colnames(counts))
  }
  ## row_data
  if(length(parameters) != 1 & nBatches == 1){
    if(is.null(fold_change_multiplier_record)){
      de_genes <- ifelse(fold_change_multiplier == 1, "no", "yes")
      fc <- fold_change_multiplier
    }else{
      de_genes <- ifelse(fold_change_multiplier_record == 1, "no", "yes")
      fc <- fold_change_multiplier_record
    }
    row_data <- data.frame("gene_name" = rownames(counts),
                           "de_gene" = de_genes,
                           "fc_gene" = fc,
                           "de_gene_group" = c(rep(paste0("Group1_Group", 2:(length(DE_group)+1)), DE_group),
                                               rep("Group1", nrow(counts)-DE_gene_number)),
                           row.names = rownames(counts))
  }else{
    row_data <- data.frame("gene_name" = rownames(counts),
                           row.names = rownames(counts))
  }
  # Establish SingleCellExperiment
  simulate_result <- SingleCellExperiment::SingleCellExperiment(list(counts = counts),
                                                                colData = col_data,
                                                                rowData = row_data)
  simulate_result <- data_conversion(SCE_object = simulate_result,
                                     return_format = return_format)
  ##############################################################################
  ####                           Ouput                                       ###
  ##############################################################################
  slot(estimated_result, "simulation_time_memory") <- list("SPARSim" = list("estimation_time" = simulate_detection$Elapsed_Time_sec,
                                                                            "estimation_memory" = simulate_detection$Peak_RAM_Used_MiB))
  slot(estimated_result, "simulation_result") <- list("SPARSim" = simulate_result)
  slot(estimated_result, "simulation_parameters") <- list("SPARSim" = used_argument[-1])
  return(estimated_result)
}
